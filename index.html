<!DOCTYPE html>
<meta charset="utf-8">
<title>Cube</title>
<style>

@import url(//fonts.googleapis.com/css?family=Yanone+Kaffeesatz:400,700);
@import url(style.css);

</style>
<div id="body">
<a href="https://github.com/square"><img src="square.png" id="logo"></a>

<h1>Cube</h1>

<h2>Time Series Data Collection & Analysis</h2>

<aside>Cube works great with <a href="../cubism/">Cubism</a>, our JavaScript library for visualizing time series.</aside>

<p><b>Cube</b> is a system for collecting timestamped events and deriving metrics. By collecting events rather than metrics, Cube lets you compute aggregate statistics <i>post hoc</i>. It also enables richer analysis, such as quantiles and histograms of arbitrary event sets. Cube is built on <a href="http://www.mongodb.org">MongoDB</a> and available under the <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache License</a> on <a href="https://github.com/square/cube">GitHub</a>.

<h2>Collecting Data</h2>

<p>An <a href="https://github.com/square/cube/wiki/Events">event</a> in Cube is simply a JSON object with a <code>type</code>, <code>time</code>, and arbitrary <code>data</code>. For example, to record an HTTP request sent to a web server, you might emit:

<aside>Events can also include an <code>id</code> attribute, allowing you to update the data associated with an earlier event.</aside>

<pre><code id="example1">{
  "type": "request",
  "time": "2012-04-23T00:05:19.488Z",
  "data": {
    "path": "/cubism/",
    "duration": 294,
    "status": 200,
    "browser": {
      "os": "Mac",
      "name": "Chrome",
      "version": 20
    }
  }
}</code></pre>

<p>Cube’s <a href="https://github.com/square/cube/wiki/Collector">collector</a> receives events and saves them to MongoDB. You can send events via UDP, HTTP POST, or WebSockets. Cube has built-in support for receiving events from <a href="http://collectd.org">collectd</a>.

<h2>Querying Events</h2>

<p>Cube defines a <a href="https://github.com/square/cube/wiki/Queries">simple language</a> for <a href="https://github.com/square/cube/wiki/Evaluator#wiki-event_get">querying events</a>. For example, you can retrieve the times of the ten most recent request events with the path "/search" like so:

<pre><code>{
  "expression": "request.eq(path, '/search')",
  "limit": 10
}</code></pre>

<p>You can intersect filters and customize which event fields are returned. To inspect the browsers of requests whose duration was <i>more</i> than 250ms but <i>less</i> than 500ms, change the expression:

<pre><code>request(browser).gt(duration, 250).lt(duration, 500)</code></pre>

<p>Cube supports both HTTP GET and WebSockets for retrieving events. WebSockets are particularly useful for streaming events in realtime to many listeners; these listeners can implement realtime dashboards or alerts based on events.

<h2>Querying Metrics</h2>

<p>You can also use Cube to group events by time, map to derived values, and reduce to <a href="https://github.com/square/cube/wiki/Metrics">aggregate metrics</a>. The language for <a href="https://github.com/square/cube/wiki/Evaluator#wiki-metric_get">computing metrics</a> is an extension of the event queries described above. For example, to count requests at five-minute intervals:

<pre><code id="example2">{
  "expression": "sum(request)",
  "start": "2012-04-23T00:00:00Z",
  "start": "2012-04-24T00:00:00Z",
  "step": 300000
}</code></pre>

<p>The first few results of which appear as:

<pre><code id="example3">{"time": "2012-04-23T00:00:00.000Z", "value": 257}
{"time": "2012-04-23T00:05:00.000Z", "value": 143}
{"time": "2012-04-23T00:10:00.000Z", "value": 223}
{"time": "2012-04-23T00:15:00.000Z", "value": 285}
{"time": "2012-04-23T00:20:00.000Z", "value": 263}
{"time": "2012-04-23T00:25:00.000Z", "value": 203}</code></pre>

<p>Or, to count requests to the path "/search", change the expression:

<pre><code>sum(request.eq(path, "/search"))</code></pre>

<p>To derive a value for events—rather than the default count—specify an expression in parentheses after the event type. For example, to compute the aggregate request <a href="http://en.wikipedia.org/wiki/Load_(computing)">load</a>:

<pre><code>sum(request(duration))</code></pre>

<p>Cube supports a variety of <a href="https://github.com/square/cube/wiki/Queries">reducers and filters</a>, and is readily extensible if you want to add your own. You can even compose arithmetic expressions, combining multiple event types and fields!

<p>Cube automatically caches metrics to capped collections and employs pyramidal aggregation for most metrics, greatly improving performance. For example, if you ask for the number of events in a particular day, Cube can use previously-computed hourly sums without a full event scan.

<p>Want to learn more? <a href="https://github.com/square/cube">See the source and documentation.</a>

<footer>
  <span style="float:right;">
    Released under the <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a>.
  </span>
  Copyright 2012 <a href="http://squareup.com">Square, Inc.</a>
</footer>
</div>

<a href="https://github.com/square/cube"><img id="fork" src="github.png"></a>

<script src="d3.v2.min.js"></script>
<script>

var start = d3.time.day.utc.floor(new Date()),
    stop = d3.time.day.offset(start, 1);

// Why? Because we can!

d3.select("#example1").text(JSON.stringify({
  "type": "request",
  "time": new Date(),
  "data": {
    "path": location.pathname,
    "query": parse(location.search),
    "duration": Math.floor(100 + Math.random() * 300),
    "status": 200,
    "browser": browser()
  }
}, null, 2));

d3.select("#example2").text(JSON.stringify({
  "expression": "sum(request)",
  "start": start,
  "stop": stop,
  "step": 3e5
}, null, 2));

d3.select("#example3").text(d3.time.minute
    .range(start, stop, 5)
    .slice(0, 6)
    .map(function(d) {
      return JSON.stringify({
        time: d,
        value: 100 + 200 * Math.random() | 0
      });
    })
    .join("\n")
    .replace(/"([:,])/g, "\"$1 "));

// Helper for parsing the query string.
function parse(search) {
  if (search) {
    var map = {};
    search.substring(1).split("&").forEach(function(param) {
      var parts = param.split("=");
      map[parts[0]] = parts[1] ? decodeURIComponent(parts[1]) : "";
    });
    return map;
  }
}

// http://www.quirksmode.org/js/detect.html
function browser() {
  var versionSearchString;

  function searchString(data) {
    for (var i = 0, n = data.length; i < n; ++i) {
      var dataString = data[i].string,
          dataProp = data[i].prop;
      versionSearchString = data[i].versionSearch || data[i].identity;
      if (dataString) {
        if (dataString.indexOf(data[i].substring) != -1) {
          return data[i].identity;
        }
      } else if (dataProp) {
        return data[i].identity;
      }
    }
  }

  function searchVersion(dataString) {
    var index = dataString.indexOf(versionSearchString);
    if (index != -1) return parseFloat(dataString.substring(index + versionSearchString.length + 1));
  }

  var browsers = [
    {string: navigator.userAgent, substring: "Chrome",   identity: "Chrome"                             },
    {string: navigator.userAgent, substring: "OmniWeb",  identity: "OmniWeb",  versionSearch: "OmniWeb/"},
    {string: navigator.vendor,    substring: "Apple",    identity: "Safari",   versionSearch: "Version" },
    {  prop: window.opera,                               identity: "Opera",    versionSearch: "Version" },
    {string: navigator.vendor,    substring: "iCab",     identity: "iCab"                               },
    {string: navigator.vendor,    substring: "KDE",      identity: "Konqueror"                          },
    {string: navigator.userAgent, substring: "Firefox",  identity: "Firefox"                            },
    {string: navigator.vendor,    substring: "Camino",   identity: "Camino"                             },
    {string: navigator.userAgent, substring: "Netscape", identity: "Netscape"                           },
    {string: navigator.userAgent, substring: "MSIE",     identity: "Explorer", versionSearch: "MSIE"    },
    {string: navigator.userAgent, substring: "Gecko",    identity: "Mozilla",  versionSearch: "rv"      },
    {string: navigator.userAgent, substring: "Mozilla",  identity: "Netscape", versionSearch: "Mozilla" }
  ];

  var oses = [
    {string: navigator.platform,  substring: "Win",    identity: "Windows"    },
    {string: navigator.platform,  substring: "Mac",    identity: "Mac"        },
    {string: navigator.userAgent, substring: "iPhone", identity: "iPhone/iPod"},
    {string: navigator.platform,  substring: "Linux",  identity: "Linux"      }
  ];

  return {
    os: searchString(oses),
    name: searchString(browsers),
    version: searchVersion(navigator.userAgent) || searchVersion(navigator.appVersion)
  };
}

</script>
<script src="highlight.min.js"></script>
